STARTUP CODE 

PART I

Options -> debugger -> uncheck run to main

select ti-stellaris as driver

Download -> use flashloader

General -> Target -> Device 
Note Floating Point Unit FPU VFPv4


program now starts with __iar_program_start not main

first instruction BL Branch with Link (function call) -> __iar_init_vfp --> initialises floating point
next instruction is function call to ?main

?main calls __low_level_init to initialise the hardware, stuff like increasing clock speed ...

if __low_level_init doesnt work __iar_data_init3 function is called to do the initialisation

PROGRAM SECTIONS INCLUDING DATA SECTION 
Could be seen in map file generated by the linker

Generate linker map file (Options -> linker -> list -> check generate linker map file)
found in output folder

MAP FILE: 

Module summary: contains memory usage: codek space in ROM and data space in ROM and RAM

Placement Summary: Lists all the program sections (.intvec, .text, .bss, .rodata, .data)

initialised data is added to .data section: data is copied from rom to ram during startup

C-standard requires all initialised values to have their values and all uninitialised set to 0 before main is called
.bss should be cleared

HOW SP got its initial value and 
HOW PC ended up at __iar_program_start

The arm cortex processor is hardwired such that after reset, it copies the bits from address 0x0 to the SP register
all the bits except the LSB to the PC, the LSB must be 1, indicates the thumb mode of the processor

Address 0x0 contains the Vector table: 
Vector table (see datasheet) contains data such as 
 - reset value of SP and 
 - start address such as PC
also contains: 
 - Exceptions: include Bus-Fault, Debug-Monitor, Hard-Fault, Memory-Manager, Non-Maskable-Interrupt
 - Interrupts 
 
 GENERIC VECTOR TABLE SHOULD BE REPLACED WITH A REAL ONE THAT CAN HANDLE ALL INTERRUPTS IN THE MCU
 
 
 PART II

compiler: compile create object files, relocatable binary
linker: link object files to other resources like libraries(eg .icf (linker script file)), object files are usually elf format files (executable and linkable file format)
elf file can be viewed using IAR's ielfdumparm.exe (see bin folder), objdump from GNU
//output file also contains disassembly code

- open object file connected to the linker 
linkers are pc specific, that is why addresses written to by compiler and linker are different <- comparing main.o and final outpt file 

HOW LINKER RESOLVES CROSS-MODULE REFERENCES TO FUNCTIONS AND VARIABLES
Meaning matching imported references to exported references

- Every object provides symbols it exports (defined in the object and can be used by other objects)
e.g main.o exports p1, p2, w1, w2, w ...
- An object might also have imported symbols (symbols it needs but does not define)
eg main.o imports function delay

Linker uses 2 lists: 
and: 
- Exported symbols 
- undefined symbols

-at start, imports is empty while exports contain only vector_table
-as linker works on main.o, it adds symbols to exports, imports are added to undefined list eg delay
- as linker works on delay.o, adds its symbol e.g delay to the exports removing it from undefined
- the vector_table is added from vector_table_M.o in the IAR library rt7M_tl.a (found in linker map file)

linker searches all object files for undefined symbols
As Linker works on main.o, it adds symbols to the Exported 

REPLACING THE VECTOR TABLE WITH YOUR OWN (keep the linker map file open)
define the symbol __vector_table in your own object linked directly into your project
this will replace the library version

-add another c file: startup_tm4c.c
//most start up codes cant be written in C, requires assembly
//Arm-cortex-m has been specifically designed to reduce the need for low level programming

int __vector_table[] = {
	0, 0
};
//linker script i.e .icf files tells where to place the merged program sections in the address space 
open linker script file: project.icf: options -> Linker > Config -> edit -> 
first tab = location of .intvec
second tab = start and end of ROM and RAM
third tab: constrols size of stack and heap 

//iar provides extension for specifying sections
int __vector_table[] @ ".intvec" = {
	0x20004000, 0x9
}; // changes in map file : .intvec declared in RAM instead of ROM, declare as constant to fix

const int __vector_table[] @ ".intvec" = {
	0x20004000, 0x9 //safe values so board doesnt hang
}; //vector table now in ROM, startup_tm4c.o